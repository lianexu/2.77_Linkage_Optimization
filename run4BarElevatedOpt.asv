setup4BarElevated();

opti = casadi.Opti();

A = opti.variable(91,1);
F_act = opti.variable(91,1);

F_max = opti.variable(); % Helper variable for max force
A_min = opti.variable(); % Helper variable for min A
A_max = opti.variable(); % Helper variable for max A

% C = 0.9;
% alpha = pi/2;
% B = 0.6;

B = opti.variable(1,1);
C = opti.variable(1,1);
D = opti.variable(1,1);
E = opti.variable(1,1);
alpha = opti.variable(1,1);

par = opti.parameter(4,1);

opti.subject_to(B > 0.1);
opti.subject_to(C > 0.1);
opti.subject_to(D > 0.1);
opti.subject_to(E > 0);

opti.subject_to(C < 1.75);
opti.subject_to(E < 0.5);
opti.subject_to(B < 1);
opti.subject_to(D < 1);

opti.subject_to(alpha > 0);
opti.subject_to(alpha < pi/2);

opti.subject_to(0.1 < A(1));
A(1) = A_fn(B, C, D, E, 0, alpha);
r = r_fn(B, C, D, E, 0, alpha);

F_act(1) = F_act_fn(B, C, D, E, 0, alpha, par); %/(T_ext_fn(par, 0)+ 1e-9); % use the relative rather than absolute amount of force needed to counter the external torque


opti.subject_to(r(2,1) >= 0);
% opti.subject_to(-r(2,4) >= 0);

for th = 1:90
    th_rad = th * pi/180; % Convert degrees to radians
    opti.subject_to(A(th+1) <  A(th));
    A(th+1) = A_fn(B, C, D, E, th_rad, alpha);
    opti.subject_to(0.1 < A(th+1)); % A should be at least 0.25 in length

    r = r_fn(B, C, D, E, th_rad, alpha);


    F_act(th+1) = F_act_fn(B, C, D, E, th_rad, alpha, par); %/(T_ext_fn(par, th_rad)+ 1e-9);
    
    opti.subject_to(r(2,1) >= 0); % linkage doesn't go through the ground
    % opti.subject_to(-r(2,4) >= 0); % linkage doesn't go through the ground
end


opti.subject_to(abs(F_act) <= F_max);
opti.subject_to(A_min <= A);
opti.subject_to(A <= A_max);
% opti.subject_to(A_max-A_min <= A_min); % stroke length constraint 
opti.subject_to(A_max);
% opti.subject_to(A_max-A_min <= 1.3);

% cost = sum(abs(F_act));
cost = F_max;
% cost = F_max + (B+C+D);

opti.minimize(cost);

%% [SOLVER]:
opts = struct();
opts.ipopt.max_iter = 5000;
opts.ipopt.nlp_scaling_method = 'gradient-based';
opti.solver('ipopt', opts);

%% [SET PARAMETER VALUES]:

opti.set_value(par, params);
opti.set_initial(B, 1.4581);
opti.set_initial(C, 2.3871);
opti.set_initial(D,0.8200);
opti.set_initial(E, 0.4154);
opti.set_initial(alpha, 1.5539);

%% [SOLVE]:
try
    soln = opti.solve();
    A_soln = soln.value(A);
    F_act_soln = soln.value(F_act);
    B_soln = soln.value(B);
    C_soln = soln.value(C);
    D_soln = soln.value(D);
    E_soln = soln.value(E);
    alpha_soln = soln.value(alpha);
catch ME
    disp('Solver failed! Inspecting debug values...');
    
    % Get the last known values of the geometric variables
    B_fail = opti.debug.value(B);
    C_fail = opti.debug.value(C);
    D_fail = opti.debug.value(D);
    alpha_fail = opti.debug.value(alpha);
    
    fprintf('Failed at: B=%.2f, C=%.2f, D=%.2f, alpha=%.2f rad\n', ...
            B_fail, C_fail, D_fail, alpha_fail);

    % Now, let's re-calculate the loop closure error for each angle
    % to see where it becomes impossible.
    closure_errors = zeros(91, 1);
    for th_deg = 0:90
        th_rad = th_deg * pi/180;
        r_val = full(r_fn(B_fail, C_fail, D_fail, th_rad, alpha_fail));
        
        % This is the expression from your constraint
        closure_errors(th_deg+1) = norm(r_val(:,1)+r_val(:,2)+r_val(:,3)+r_val(:,4));
    end
    
    % Plot the error to find the problem area
    figure('Name', 'Loop Closure Error at Failure');
    plot(0:90, closure_errors, 'r-o');
    hold on;
    plot(0:90, 0.001*ones(91,1), 'b--'); % Your tolerance
    xlabel('Theta (degrees)');
    ylabel('Loop Closure Error (norm)');
    legend('Actual Error', 'Constraint Tolerance');
    grid on;
    
    % Rethrow the original error
    rethrow(ME);
end